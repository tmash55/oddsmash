import { NextRequest, NextResponse } from 'next/server'
import { ImageAnnotatorClient } from '@google-cloud/vision'
import OpenAI from 'openai'
import { getMarketApiKey, getMarketsForSport, type SportMarket } from '@/lib/constants/markets'
import { createClient } from '@/libs/supabase/server'
import { sportsbooks } from '@/data/sportsbooks'
import { calculateAllHitRatesForLine, shouldRecalculateForLine } from "@/lib/hit-rate-calculator"

interface BetSelection {
  id: string
  player?: string
  market: string
  line?: number
  betType: 'over' | 'under' | 'moneyline' | 'spread'
  sport: string
  sportApiKey: string // The odds API sport key (e.g., 'baseball_mlb')
  marketApiKey: string // The odds API market key (e.g., 'batter_home_runs')
  gameId?: string // Will be populated after event matching
  confidence: number
  rawText: string
  metadata: {
    odds?: string
    awayTeam?: string
    homeTeam?: string
    gameTime?: string
    gameDate?: string
  }
}

interface BetslipExtraction {
  selections: BetSelection[]
  confidence: number
  rawText: string
  metadata: {
    sportsbook?: string
    totalOdds?: string
    wagerAmount?: string
    totalPayout?: string
  }
}

// Game data interface for event matching
interface GameData {
  sport_key: string
  event_id: string
  commence_time: string
  home_team: {
    name: string
    abbreviation: string
  }
  away_team: {
    name: string
    abbreviation: string
  }
  status: string
}

// Types for odds fetching (matching refresh endpoint)
interface Outcome {
  name: string
  price: number
  point?: number
  description?: string
  sid?: string
  link?: string
}

interface Market {
  key: string
  outcomes: Outcome[]
}

interface Bookmaker {
  key: string
  title: string
  last_update: string
  markets: Market[]
}

interface OddsResponse {
  id: string
  sport_key: string
  sport_title: string
  commence_time: string
  home_team: string
  away_team: string
  bookmakers: Bookmaker[]
}

interface OddsMetadata {
  matches_found: number
  total_bookmakers: number
  best_odds: number | null
  best_book: string | null
  player_searched: string
  line_searched: number
  bet_type_searched: string
  market_searched: string
  last_updated: string
  error?: string
}

// Initialize OpenAI client
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
})

// Initialize Google Vision client
let visionClient: ImageAnnotatorClient | null = null

function getVisionClient() {
  if (!visionClient) {
    try {
      // Try to initialize with environment credentials
      if (process.env.GOOGLE_APPLICATION_CREDENTIALS || 
          (process.env.GOOGLE_CLOUD_PRIVATE_KEY && process.env.GOOGLE_CLOUD_CLIENT_EMAIL)) {
        
        const config = process.env.GOOGLE_APPLICATION_CREDENTIALS 
          ? { keyFilename: process.env.GOOGLE_APPLICATION_CREDENTIALS }
          : {
              credentials: {
                private_key: process.env.GOOGLE_CLOUD_PRIVATE_KEY?.replace(/\\n/g, '\n'),
                client_email: process.env.GOOGLE_CLOUD_CLIENT_EMAIL,
              },
              projectId: process.env.GOOGLE_CLOUD_PROJECT_ID,
            }
        
        visionClient = new ImageAnnotatorClient(config)
        console.log('Google Vision API initialized successfully')
      } else {
        console.warn('Google Vision API credentials not found, using mock OCR')
      }
    } catch (error) {
      console.error('Failed to initialize Google Vision API:', error)
    }
  }
  return visionClient
}

// Real OCR function using Google Vision API
async function extractTextFromImageWithVision(imageBuffer: Buffer): Promise<string> {
  const client = getVisionClient()
  
  if (!client) {
    console.log('‚ö†Ô∏è Google Vision not configured, using mock extraction')
    return await extractTextFromImageMock(imageBuffer)
  }

  try {
    console.log('üîç Starting Google Vision OCR extraction...')
    
    let structuredText = ''
    let documentText = ''
    
    // Method 1: Document Text Detection (best for structured documents like betslips)
    console.log('Method 1: Document text detection...')
    try {
      const [documentResult] = await client.documentTextDetection({
        image: { content: new Uint8Array(imageBuffer) },
      })

      if (documentResult.fullTextAnnotation?.text) {
        documentText = documentResult.fullTextAnnotation.text
        console.log('Document text detection successful, extracted text length:', documentText.length)
      }

      
      // Try to extract structured text using the document hierarchy
      if (documentResult.fullTextAnnotation.pages && documentResult.fullTextAnnotation.pages[0]) {
        const page = documentResult.fullTextAnnotation.pages[0]
        console.log(`Document structure: ${page.blocks?.length || 0} blocks`)
        
        // Build structured text by processing blocks, paragraphs, and words
        if (page.blocks) {
          const structuredLines: string[] = []
          
          for (const block of page.blocks) {
            if (block.paragraphs) {
              for (const paragraph of block.paragraphs) {
                if (paragraph.words) {
                  const words = paragraph.words.map(word => {
                    if (word.symbols) {
                      return word.symbols.map(symbol => symbol.text || '').join('')
                    }
                    return ''
                  }).filter(word => word.length > 0)
                  
                  if (words.length > 0) {
                    structuredLines.push(words.join(' '))
                  }
                }
              }
            }
          }
          
          structuredText = structuredLines.join('\n')
          console.log('Structured text extraction successful, lines:', structuredLines.length)
        }
      }
    } catch (docError) {
      console.log('Document text detection failed:', docError.message)
    }
    
    // Method 2: Regular Text Detection (fallback)
    console.log('Method 2: Regular text detection...')
    let regularText = ''
    let detailsText = ''
    
    try {
      const [textResult] = await client.textDetection({
        image: { content: new Uint8Array(imageBuffer) },
      })
      
      if (textResult.textAnnotations && textResult.textAnnotations.length > 0) {
        // The first annotation contains the full text
        regularText = textResult.textAnnotations[0].description || ''
        console.log('Regular text detection successful, extracted text length:', regularText.length)
        
        // Also extract individual text annotations with positions for better structure
        const individualTexts = textResult.textAnnotations.slice(1).map(annotation => ({
          text: annotation.description || '',
          bounds: annotation.boundingPoly
        }))
        
        // Try to reconstruct text based on position (top to bottom, left to right)
        if (individualTexts.length > 0) {
          // Sort by Y position (top to bottom), then X position (left to right)
          const sortedTexts = individualTexts.sort((a, b) => {
            if (!a.bounds?.vertices || !b.bounds?.vertices) return 0
            
            const aY = a.bounds.vertices[0]?.y || 0
            const bY = b.bounds.vertices[0]?.y || 0
            const aX = a.bounds.vertices[0]?.x || 0
            const bX = b.bounds.vertices[0]?.x || 0
            
            // If Y positions are close (same line), sort by X
            if (Math.abs(aY - bY) < 20) {
              return aX - bX
            }
            
            return aY - bY
          })
          
          // Group texts by approximate Y position (lines)
          const lines: string[][] = []
          let currentLine: string[] = []
          let lastY = -1
          
          for (const item of sortedTexts) {
            const y = item.bounds?.vertices?.[0]?.y || 0
            
            // If this is a new line (Y position changed significantly)
            if (lastY !== -1 && Math.abs(y - lastY) > 20) {
              if (currentLine.length > 0) {
                lines.push([...currentLine])
                currentLine = []
              }
            }
            
            currentLine.push(item.text)
            lastY = y
          }
          
          // Add the last line
          if (currentLine.length > 0) {
            lines.push(currentLine)
          }
          
          detailsText = lines.map(line => line.join(' ')).join('\n')
          console.log('Position-based text reconstruction successful, lines:', lines.length)
        }
      }
    } catch (textError) {
      console.log('Regular text detection failed:', textError.message)
    }

    // Method 3: Enhanced FanDuel-specific extraction
    console.log('Method 3: Enhanced FanDuel-specific extraction...')
    let fanDuelText = ''
    
    try {
      // Use more aggressive OCR settings for FanDuel betslips
      const [enhancedResult] = await client.textDetection({
        image: { 
          content: new Uint8Array(imageBuffer)
        },
        imageContext: {
          languageHints: ['en'],
          textDetectionParams: {
            enableTextDetectionConfidenceScore: true
          }
        }
      })
      
      if (enhancedResult.textAnnotations && enhancedResult.textAnnotations.length > 0) {
        // Filter out low-confidence detections and reconstruct
        const confidentTexts = enhancedResult.textAnnotations.slice(1)
          .filter(annotation => {
            // Only include text that looks like it could be part of a betslip
            const text = annotation.description || ''
            return text.length > 0 && 
                   !text.match(/^[^\w\s]$/) && // Skip single special characters
                   text.trim().length > 0
          })
          .map(annotation => ({
            text: annotation.description || '',
            bounds: annotation.boundingPoly,
            confidence: annotation.confidence || 0
          }))
        
        // Sort by position and reconstruct
        const sortedConfidentTexts = confidentTexts.sort((a, b) => {
          if (!a.bounds?.vertices || !b.bounds?.vertices) return 0
          
          const aY = a.bounds.vertices[0]?.y || 0
          const bY = b.bounds.vertices[0]?.y || 0
          const aX = a.bounds.vertices[0]?.x || 0
          const bX = b.bounds.vertices[0]?.x || 0
          
          // If Y positions are close (same line), sort by X
          if (Math.abs(aY - bY) < 25) {
            return aX - bX
          }
          
          return aY - bY
        })
        
        // Group into lines with better line detection for FanDuel format
        const fanDuelLines: string[] = []
        let currentFanDuelLine: string[] = []
        let lastFanDuelY = -1
        
        for (const item of sortedConfidentTexts) {
          const y = item.bounds?.vertices?.[0]?.y || 0
          
          // FanDuel has tighter line spacing, so use smaller threshold
          if (lastFanDuelY !== -1 && Math.abs(y - lastFanDuelY) > 15) {
            if (currentFanDuelLine.length > 0) {
              fanDuelLines.push(currentFanDuelLine.join(' '))
              currentFanDuelLine = []
            }
          }
          
          currentFanDuelLine.push(item.text)
          lastFanDuelY = y
        }
        
        // Add the last line
        if (currentFanDuelLine.length > 0) {
          fanDuelLines.push(currentFanDuelLine.join(' '))
        }
        
        fanDuelText = fanDuelLines.join('\n')
        console.log('FanDuel-specific extraction successful, lines:', fanDuelLines.length)
      }
    } catch (enhancedError) {
      console.log('Enhanced FanDuel extraction failed:', enhancedError.message)
    }
    
    // Choose the best text based on length, structure, and content
    const candidates = [
      { text: structuredText, name: 'structured', length: structuredText.length },
      { text: documentText, name: 'document', length: documentText.length },
      { text: detailsText, name: 'position-based', length: detailsText.length },
      { text: regularText, name: 'regular', length: regularText.length },
      { text: fanDuelText, name: 'fanduel-enhanced', length: fanDuelText.length }
    ].filter(candidate => candidate.length > 0)
    
    if (candidates.length === 0) {
      throw new Error('No text detected in image')
    }
    
    // Sort by length (longer is usually better for betslips) but also consider content quality
    candidates.sort((a, b) => {
      // Prioritize candidates that contain key betslip terms
      const aHasKey = a.text.toLowerCase().includes('strikeout') || 
                      a.text.toLowerCase().includes('parlay') ||
                      a.text.toLowerCase().includes('pick')
      const bHasKey = b.text.toLowerCase().includes('strikeout') || 
                      b.text.toLowerCase().includes('parlay') ||
                      b.text.toLowerCase().includes('pick')
      
      if (aHasKey && !bHasKey) return -1
      if (!aHasKey && bHasKey) return 1
      
      // If both have key terms or neither do, sort by length
      return b.length - a.length
    })
    
    const bestCandidate = candidates[0]
    console.log(`Using ${bestCandidate.name} text extraction (${bestCandidate.length} chars)`)
    
    // Log first 500 chars of each method for debugging
    console.log('\nüìä OCR Results Comparison:')
    candidates.forEach(candidate => {
      const preview = candidate.text.substring(0, 200).replace(/\n/g, ' ')
      const hasStrikeout = candidate.text.toLowerCase().includes('strikeout')
      const hasParlay = candidate.text.toLowerCase().includes('parlay')
      console.log(`${candidate.name} (${candidate.length} chars, strikeout: ${hasStrikeout}, parlay: ${hasParlay}): ${preview}...`)
    })
    console.log('')
    
    return bestCandidate.text
    
  } catch (error) {
    console.error('Google Vision API error:', error)
    throw error
  }
}

// Mock OCR function - fallback for development
async function extractTextFromImageMock(imageBuffer: Buffer): Promise<string> {
  // Simulate processing delay
  await new Promise(resolve => setTimeout(resolve, 2000))
  
  // Mock extracted text that looks like a real betslip
  return `
    DraftKings Sportsbook
    
    Parlay Bet
    
    Aaron Judge - Home Runs
    Over 0.5 (+110)
    
    Mookie Betts - Hits
    Over 1.5 (-120)
    
    Freddie Freeman - RBIs
    Over 0.5 (+105)
    
    Total Odds: +650
    Wager: $25.00
    To Win: $162.50
  `
}

// Main OCR function that tries Vision API first, falls back to mock
async function extractTextFromImage(imageBuffer: Buffer): Promise<string> {
  try {
    // Try Google Vision API first
    return await extractTextFromImageWithVision(imageBuffer)
  } catch (error) {
    console.warn('Google Vision API failed, using mock OCR:', error.message)
    // Fall back to mock for development
    return await extractTextFromImageMock(imageBuffer)
  }
}

// LLM-powered betslip parser
async function parseWithLLM(ocrText: string): Promise<BetSelection[]> {
  try {
    const prompt = `You are an expert sports betting slip parser. Extract all individual player prop bets from this OCR text from ANY sportsbook (FanDuel, DraftKings, BetMGM, Caesars, ESPN BET, etc.).

CRITICAL PARLAY PARSING RULES:
- If this is a parlay bet, DO NOT use the total parlay odds (like +3200) for individual selections
- Look for individual odds listed near each player's selection (like +450, -120, etc.)
- If a selection doesn't have individual odds listed, use "N/A" for odds
- Total parlay odds (usually large numbers like +3200, +650) should be ignored for individual selections
- Each player should have their own individual odds, not the combined parlay odds

SPORTSBOOK FORMAT VARIATIONS:
- FanDuel: "TO HIT A HOME RUN", "TO RECORD X+ HITS", "PROFIT BOOST", "Strikeouts Thrown", "Over X.5"
- DraftKings: "Same Game Parlay", "SGP", different layout
- BetMGM: "Player Props", different team format
- Caesars: "Boosts", different odds display
- Handle any sportsbook's unique terminology and layout

SPORT DETECTION:
- Look for sport indicators in team names, player names, and markets
- Common sports: "Baseball/MLB", "Basketball/NBA", "Hockey/NHL", "Football/NFL"
- Return the sport as one of: "Baseball", "Basketball", "Hockey", "Football"

MARKET STANDARDIZATION (works across all sportsbooks):
- "TO HIT A HOME RUN", "HOME RUN", "HR" ‚Üí "Home_Runs"
- "TO HIT A DOUBLE", "TO RECORD A DOUBLE", "DOUBLE", "2B" ‚Üí "Doubles"
- "TO HIT A TRIPLE", "TO RECORD A TRIPLE", "TRIPLE", "3B" ‚Üí "Triples"
- "TO HIT A SINGLE", "TO RECORD A SINGLE", "SINGLE", "1B" ‚Üí "Singles"
- "TO RECORD A STOLEN BASE", "STOLEN BASE", "SB" ‚Üí "Stolen_Bases"  
- "TO RECORD X+ HITS", "X+ HITS", "HITS" ‚Üí "Hits"
- "X+ STRIKEOUTS", "STRIKEOUTS", "K's", "SO", "Strikeouts Thrown", "OVER X.5 STRIKEOUTS" ‚Üí "Strikeouts"
- "TO RECORD X+ TOTAL BASES", "X+ TOTAL BASES", "TB" ‚Üí "Total_Bases"
- "TO RECORD X+ RBIS", "X+ RBIS", "RBI", "RUNS BATTED IN" ‚Üí "RBIs"
- "POINTS", "PTS" ‚Üí "Points"
- "REBOUNDS", "REB" ‚Üí "Rebounds"
- "ASSISTS", "AST" ‚Üí "Assists"
- "GOALS" ‚Üí "Goals"
- "SHOTS ON GOAL", "SOG" ‚Üí "Shots"

CRITICAL LINE EXTRACTION RULES:
PAY CLOSE ATTENTION TO THE EXACT FORMAT IN THE BETSLIP:

1. "Over X.5" format (e.g., "Over 6.5", "Over 4.5"):
   - Extract the EXACT decimal number shown
   - "Over 6.5 strikeouts" ‚Üí line: 6.5
   - "Over 4.5 strikeouts" ‚Üí line: 4.5
   - "Over 1.5 hits" ‚Üí line: 1.5

2. "X+" format (e.g., "6+", "7+", "2+"):
   - For STRIKEOUTS: Keep the exact whole number (strikeouts are always whole numbers in real games)
   - "6+ strikeouts" ‚Üí line: 6
   - "7+ strikeouts" ‚Üí line: 7
   - For OTHER markets: Convert to X-0.5
   - "2+ hits" ‚Üí line: 1.5
   - "3+ total bases" ‚Üí line: 2.5

3. Binary props (no number):
   - "TO HIT A HOME RUN" ‚Üí line: 0.5
   - "TO HIT A DOUBLE" ‚Üí line: 0.5
   - "TO RECORD A HIT" ‚Üí line: 0.5

EXAMPLES:
- "Over 6.5 Strikeouts" ‚Üí line: 6.5 (exact decimal)
- "6+ Strikeouts" ‚Üí line: 6 (whole number for X+ format)
- "Over 4.5 Strikeouts" ‚Üí line: 4.5 (exact decimal)
- "4+ Strikeouts" ‚Üí line: 4 (whole number for X+ format)
- "Over 1.5 Hits" ‚Üí line: 1.5 (exact decimal)
- "2+ Hits" ‚Üí line: 1.5 (X+ format converted to X-0.5)

TEAM NAME VARIATIONS:
- Handle abbreviations: "NYY" = "New York Yankees", "LAD" = "Los Angeles Dodgers"
- Handle @ vs "at" vs "vs" in matchups
- Extract both full team names and abbreviations

ODDS PARSING EXAMPLES:
For this text: "2 leg parlay Yainer Diaz To Hit A Home Run, Gavin Sheets To Hit A Home Run +3200 Yainer Diaz TO HIT A HOME RUN Houston Astros @ Athletics Gavin Sheets TO HIT A HOME RUN +450"
- "+3200" is the TOTAL PARLAY ODDS - ignore this for individual selections
- "+450" appears near Gavin Sheets, so that's his individual odds
- Yainer Diaz has no individual odds listed, so use "N/A"

FANDUEL SPECIFIC PARSING:
FanDuel uses two main formats for strikeouts:
1. "Over X.5" format: "Over 6.5\\nJacob deGrom Strikeouts Thrown" ‚Üí line: 6.5
2. "X+" format: "6+\\nJacob deGrom Strikeouts Thrown" ‚Üí line: 6

Look carefully at the text to determine which format is being used and extract the line accordingly.

PARSING STRATEGY:
1. First, identify if this is a parlay (look for "X Pick Parlay" or "X leg parlay")
2. Count how many picks are expected based on the parlay description
3. Scan through the text systematically to find each player
4. For each player, look for the line format BEFORE the player name
5. Extract the exact line value based on the format rules above
6. Extract player name, market type, teams, game time
7. Verify you found the expected number of selections before returning

RULES:
1. Only extract individual player props, ignore team totals
2. Standardize market names using the mapping above
3. Extract exact player names (First Last format)
4. For odds: find odds specifically associated with each player, ignore parlay totals
5. Parse team matchups from game info lines
6. Extract game times in original format
7. Extract line values using the EXACT format rules above - this is CRITICAL
8. Ignore single characters, team logos, or UI elements
9. Detect the sport based on context clues
10. If individual odds are not clear, use "N/A" rather than guessing
11. Handle any sportsbook format - focus on core betting information
12. CRITICAL: Extract ALL players mentioned - do not skip any selections
13. MOST IMPORTANT: Pay attention to whether the line is "Over X.5" or "X+" format and extract accordingly

OCR TEXT:
${ocrText}

Return a valid JSON array with this exact format:
[
  {
    "player": "Player Name",
    "sport": "Baseball",
    "market": "Strikeouts",
    "line": 6.5,
    "betType": "over",
    "odds": "N/A",
    "awayTeam": "Away Team",
    "homeTeam": "Home Team",
    "gameTime": "6:40 PM"
  }
]

Return only the JSON array, no other text.`

    console.log('ü§ñ Sending betslip to OpenAI for parsing...')
    console.log('üìù OCR Text Preview (first 500 chars):', ocrText.substring(0, 500))
    
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini", // Cheap and effective
      messages: [{ role: "user", content: prompt }],
      temperature: 0.1, // Low temperature for consistency
      max_tokens: 1500, // Increased token limit for larger responses
    })

    const content = response.choices[0].message.content
    if (!content) {
      throw new Error('No response from OpenAI')
    }

    console.log('ü§ñ OpenAI response:', content)

    // Clean and parse the JSON response - handle markdown code blocks
    let cleanedContent = content.trim()
    
    // Remove markdown code blocks if present
    if (cleanedContent.startsWith('```json')) {
      cleanedContent = cleanedContent.replace(/^```json\s*/, '').replace(/\s*```$/, '')
    } else if (cleanedContent.startsWith('```')) {
      cleanedContent = cleanedContent.replace(/^```\s*/, '').replace(/\s*```$/, '')
    }
    
    console.log('üßπ Cleaned content for parsing:', cleanedContent.substring(0, 200) + '...')

    // Parse the JSON response
    const parsedSelections = JSON.parse(cleanedContent)
    
    if (!Array.isArray(parsedSelections)) {
      throw new Error('OpenAI did not return an array')
    }

    console.log(`üéØ LLM found ${parsedSelections.length} selections`)

    // Convert to our BetSelection format with sport and market mapping
    const selections: BetSelection[] = parsedSelections.map((selection: any, index: number) => {
      // Map sport to API key
      const sportApiKey = mapSportToApiKey(selection.sport)
      
      // Map market to API key using our constants
      const marketApiKey = getMarketApiKey(sportApiKey, selection.market)
      
      // Default line values based on market if not provided
      let line = selection.line || 0.5 // Default to 0.5
      
      // Market-specific defaults if line is missing
      if (!selection.line) {
        switch (selection.market) {
          case 'Home_Runs':
          case 'Stolen_Bases':
          case 'Hits':
          case 'Doubles':
          case 'Triples':
          case 'Singles':
            line = 0.5
            break
          case 'Strikeouts':
            line = 5.5 // Common strikeout line
            break
          case 'Total_Bases':
            line = 1.5 // Common total bases line
            break
          case 'RBIs':
            line = 0.5
            break
          case 'Points':
            line = 15.5 // Common NBA points line
            break
          case 'Rebounds':
            line = 7.5 // Common rebounds line
            break
          case 'Assists':
            line = 5.5 // Common assists line
            break
          default:
            line = 0.5
        }
      }

      // Determine bet type from the LLM response or OCR text analysis
      let betType: 'over' | 'under' = 'over' // Default to over
      
      // First, check if the LLM provided a betType
      if (selection.betType && (selection.betType === 'over' || selection.betType === 'under')) {
        betType = selection.betType
      } else {
        // Fallback: Check if the original text indicates an under bet
        const rawTextLower = ocrText.toLowerCase()
        const playerNameLower = selection.player?.toLowerCase() || ''
        
        // Look for "under" in the context of this specific player
        const playerContext = rawTextLower.includes(playerNameLower) 
          ? rawTextLower.substring(rawTextLower.indexOf(playerNameLower))
          : rawTextLower
        
        if (playerContext.includes('under') && !playerContext.includes('over')) {
          betType = 'under'
        }
      }

      const betSelection: BetSelection = {
        id: `${index + 1}`,
        player: selection.player,
        market: selection.market,
        line: line,
        betType: betType,
        sport: selection.sport,
        sportApiKey: sportApiKey,
        marketApiKey: marketApiKey,
        confidence: 0.9, // High confidence for LLM parsing
        rawText: `${selection.player} ${selection.market}`,
        metadata: {
          odds: selection.odds,
          awayTeam: selection.awayTeam,
          homeTeam: selection.homeTeam,
          gameTime: selection.gameTime,
        }
      }

      console.log(`üìù Selection ${index + 1}: ${betSelection.player} - ${betSelection.market} ${betSelection.line} (${betSelection.metadata.odds}) [${betSelection.sport}/${betSelection.sportApiKey}] -> ${betSelection.marketApiKey}`)
      
      return betSelection
    })

    console.log(`‚úÖ Successfully parsed ${selections.length} selections with LLM`)

    return selections

  } catch (error) {
    console.error('‚ùå LLM parsing failed:', error)
    console.error('Raw OCR text that failed:', ocrText.substring(0, 1000))
    // Return empty array instead of throwing - we can add fallback logic later
    return []
  }
}

// Helper function to map sport names to API keys
function mapSportToApiKey(sport: string): string {
  const sportMapping: Record<string, string> = {
    'Baseball': 'baseball_mlb',
    'Basketball': 'basketball_nba',
    'Hockey': 'icehockey_nhl',
    'Football': 'americanfootball_nfl',
    'College Basketball': 'basketball_ncaab',
    'College Football': 'americanfootball_ncaaf'
  }
  
  return sportMapping[sport] || 'baseball_mlb' // Default to MLB if unknown
}

// Function to fetch today's games for event matching
async function fetchTodaysGames(sport: string, date: string): Promise<Record<string, GameData>> {
  try {
    const apiKey = process.env.ODDS_API_KEY
    if (!apiKey) {
      console.warn('ODDS_API_KEY not configured')
      return {}
    }
    
    // Get games for the date (extend to next day to catch evening games in US timezones)
    const startTime = `${date}T00:00:00Z`
    const endTime = `${date}T23:59:59Z`
    
    // Also include early hours of next day to catch late games
    const nextDay = new Date(date)
    nextDay.setDate(nextDay.getDate() + 1)
    const nextDayStr = nextDay.toISOString().split('T')[0]
    const extendedEndTime = `${nextDayStr}T06:00:00Z` // Include games up to 6 AM next day UTC
    
    const url = `https://api.the-odds-api.com/v4/sports/${sport}/events?apiKey=${apiKey}&dateFormat=iso&commenceTimeFrom=${startTime}&commenceTimeTo=${extendedEndTime}`
    
    console.log(`üéØ Fetching games from Odds API: ${url}`)
    
    const response = await fetch(url)
    if (!response.ok) {
      console.error(`Odds API error: ${response.status} ${response.statusText}`)
      return {}
    }
    
    const events = await response.json()
    console.log(`üìÖ Odds API returned ${events.length} games for ${date}`)
    
    // Convert to our GameData format and index by event_id
    const games: Record<string, GameData> = {}
    events.forEach((event: any) => {
      games[event.id] = {
        sport_key: event.sport_key,
        event_id: event.id,
        commence_time: event.commence_time,
        home_team: {
          name: event.home_team,
          abbreviation: event.home_team // API doesn't provide abbreviations in events endpoint
        },
        away_team: {
          name: event.away_team,
          abbreviation: event.away_team
        },
        status: 'scheduled' // Default status
      }
    })
    
    return games
  } catch (error) {
    console.error('Error fetching games from Odds API:', error)
    return {}
  }
}

// Helper function to normalize team names for matching
function normalizeTeamName(teamName: string): string {
  if (!teamName) return ''
  
  let normalized = teamName
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, '') // Remove special characters
    .replace(/\s+/g, ' ') // Normalize whitespace
    .trim()
    
  // Handle common MLB team abbreviations and variations
  const teamMappings: Record<string, string> = {
    // Texas Rangers variations
    'tex rangers': 'texas rangers',
    'tex': 'texas rangers',
    'texas': 'texas rangers',
    'rangers': 'texas rangers',
    
    // Pittsburgh Pirates variations
    'pit pirates': 'pittsburgh pirates', 
    'pit': 'pittsburgh pirates',
    'pittsburgh': 'pittsburgh pirates',
    'pirates': 'pittsburgh pirates',
    
    // Baltimore Orioles variations
    'bal orioles': 'baltimore orioles',
    'bal': 'baltimore orioles', 
    'baltimore': 'baltimore orioles',
    'orioles': 'baltimore orioles',
    
    // New York Yankees variations
    'ny yankees': 'new york yankees',
    'nyy': 'new york yankees',
    'new york yankees': 'new york yankees',
    'yankees': 'new york yankees',
    
    // Arizona Diamondbacks variations
    'ari diamondbacks': 'arizona diamondbacks',
    'ari': 'arizona diamondbacks',
    'arizona': 'arizona diamondbacks',
    'diamondbacks': 'arizona diamondbacks',
    
    // Colorado Rockies variations
    'col rockies': 'colorado rockies',
    'col': 'colorado rockies',
    'colorado': 'colorado rockies',
    'rockies': 'colorado rockies',
    
    // Houston Astros variations
    'hou astros': 'houston astros',
    'hou': 'houston astros',
    'houston': 'houston astros',
    'astros': 'houston astros',
    
    // Los Angeles Angels variations
    'la angels': 'los angeles angels',
    'laa': 'los angeles angels',
    'los angeles angels': 'los angeles angels',
    'angels': 'los angeles angels',
    
    // Milwaukee Brewers variations
    'mil brewers': 'milwaukee brewers',
    'mil': 'milwaukee brewers',
    'milwaukee': 'milwaukee brewers',
    'brewers': 'milwaukee brewers',
    
    // Minnesota Twins variations
    'min twins': 'minnesota twins',
    'min': 'minnesota twins',
    'minnesota': 'minnesota twins',
    'twins': 'minnesota twins',
    
    // Common variations
    'cle guardians': 'cleveland guardians',
    'cleveland': 'cleveland guardians',
    'sf giants': 'san francisco giants',
    'san francisco': 'san francisco giants',
    'tb rays': 'tampa bay rays',
    'tampa bay': 'tampa bay rays',
    'ny mets': 'new york mets',
    'atl braves': 'atlanta braves',
    'atlanta': 'atlanta braves',
    'was nationals': 'washington nationals',
    'washington': 'washington nationals'
  }
  
  // Check if we have a direct mapping
  if (teamMappings[normalized]) {
    return teamMappings[normalized]
  }
  
  return normalized
}

// Helper function to calculate team name similarity
function calculateTeamSimilarity(name1: string, name2: string): number {
  const norm1 = normalizeTeamName(name1)
  const norm2 = normalizeTeamName(name2)
  
  // Exact match
  if (norm1 === norm2) return 1.0
  
  // Check if one contains the other
  if (norm1.includes(norm2) || norm2.includes(norm1)) return 0.9
  
  // Check for partial matches with common team names
  const words1 = norm1.split(' ')
  const words2 = norm2.split(' ')
  const commonWords = words1.filter(word => words2.includes(word) && word.length > 2) // Only count meaningful words
  
  if (commonWords.length === 0) return 0
  
  // Higher score for matching team names
  if (commonWords.some(word => ['rangers', 'pirates', 'orioles', 'yankees', 'diamondbacks', 'rockies', 'astros', 'angels', 'brewers', 'twins'].includes(word))) {
    return 0.8
  }
  
  return commonWords.length / Math.max(words1.length, words2.length)
}

// Helper function to find matching game
function findMatchingGame(games: Record<string, GameData>, awayTeam?: string, homeTeam?: string): GameData | null {
  if (!awayTeam || !homeTeam) {
    console.log(`‚ùå Missing team data: away="${awayTeam}", home="${homeTeam}"`)
    return null
  }
  
  console.log(`üîç Looking for game: "${awayTeam}" @ "${homeTeam}"`)
  
  let bestMatch: { game: GameData; score: number; config: string } | null = null
  
  for (const [gameId, game] of Object.entries(games)) {
    // Try both orientations: parsed (away @ home) and flipped (home @ away)
    const configs = [
      {
        name: 'normal',
        awayScore: calculateTeamSimilarity(awayTeam, game.away_team.name),
        homeScore: calculateTeamSimilarity(homeTeam, game.home_team.name)
      },
      {
        name: 'flipped',
        awayScore: calculateTeamSimilarity(awayTeam, game.home_team.name),
        homeScore: calculateTeamSimilarity(homeTeam, game.away_team.name)
      }
    ]
    
    for (const config of configs) {
      const score = (config.awayScore + config.homeScore) / 2
      
      console.log(`   üéØ ${config.name}: "${game.away_team.name}" vs "${game.home_team.name}" = ${score.toFixed(2)} (away: ${config.awayScore.toFixed(2)}, home: ${config.homeScore.toFixed(2)})`)
      
      // Require a minimum similarity threshold
      if (score >= 0.6 && (!bestMatch || score > bestMatch.score)) {
        bestMatch = { game, score, config: config.name }
      }
    }
  }
  
  if (bestMatch) {
    console.log(`‚úÖ Best match (${bestMatch.config}): ${bestMatch.game.away_team.name} @ ${bestMatch.game.home_team.name} (score: ${bestMatch.score.toFixed(2)})`)
    return bestMatch.game
  }
  
  console.log(`‚ùå No suitable game match found (all scores below 0.6 threshold)`)
  return null
}

// Function to map sport names to API keys
function getSportApiKey(sport: string): string {
  return mapSportToApiKey(sport)
}

// Enhanced parsing function that returns proper structure
async function parseWithLLMEnhanced(text: string): Promise<{
  success: boolean
  data?: {
    sportsbook: string
    selections: BetSelection[]
    confidence: number
  }
  error?: string
}> {
  try {
    const selections = await parseWithLLM(text)
    
    if (selections.length === 0) {
      return {
        success: false,
        error: 'No selections found in betslip'
      }
    }

    // Enhanced sportsbook detection with more identifiers
    let sportsbook = 'Unknown'
    const lowerText = text.toLowerCase()
    
    // FanDuel identifiers
    if (lowerText.includes('profit boost') || 
        lowerText.includes('to hit') || 
        lowerText.includes('to record') ||
        lowerText.includes('fanduel') ||
        lowerText.includes('fan duel')) {
      sportsbook = 'FanDuel'
    }
    // DraftKings identifiers  
    else if (lowerText.includes('draftkings') || 
             lowerText.includes('draft kings') ||
             lowerText.includes('sgp') || 
             lowerText.includes('same game parlay') ||
             lowerText.includes('dk')) {
      sportsbook = 'DraftKings'
    }
    // BetMGM identifiers
    else if (lowerText.includes('betmgm') || 
             lowerText.includes('bet mgm') ||
             lowerText.includes('mgm')) {
      sportsbook = 'BetMGM'
    }
    // Caesars identifiers
    else if (lowerText.includes('caesars') || 
             lowerText.includes('caesar') ||
             lowerText.includes('williamhill') ||
             lowerText.includes('william hill')) {
      sportsbook = 'Caesars'
    }
    // ESPN BET identifiers
    else if (lowerText.includes('espn bet') || 
             lowerText.includes('espnbet') ||
             lowerText.includes('espn')) {
      sportsbook = 'ESPN BET'
    }
    // Hard Rock Bet identifiers
    else if (lowerText.includes('hard rock') || 
             lowerText.includes('hardrockbet') ||
             lowerText.includes('hardrock')) {
      sportsbook = 'Hard Rock Bet'
    }
    // Fanatics identifiers
    else if (lowerText.includes('fanatics')) {
      sportsbook = 'Fanatics'
    }
    // BetRivers identifiers
    else if (lowerText.includes('betrivers') || 
             lowerText.includes('bet rivers') ||
             lowerText.includes('rivers')) {
      sportsbook = 'BetRivers'
    }
    // Pinnacle identifiers
    else if (lowerText.includes('pinnacle')) {
      sportsbook = 'Pinnacle'
    }
    // Legacy sportsbooks
    else if (lowerText.includes('pointsbet') || 
             lowerText.includes('points bet')) {
      sportsbook = 'PointsBet'
    }
    else if (lowerText.includes('barstool')) {
      sportsbook = 'Barstool'
    }
    else if (lowerText.includes('wynn') || 
             lowerText.includes('wynnbet')) {
      sportsbook = 'WynnBET'
    }
    else if (lowerText.includes('unibet')) {
      sportsbook = 'Unibet'
    }
    else if (lowerText.includes('bet365')) {
      sportsbook = 'bet365'
    }

    console.log(`üè¢ Detected sportsbook: ${sportsbook}`)

    const averageConfidence = selections.reduce((sum, s) => sum + s.confidence, 0) / selections.length

    return {
      success: true,
      data: {
        sportsbook,
        selections,
        confidence: averageConfidence
      }
    }
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown parsing error'
    }
  }
}

// Function to save betslip to database
async function saveBetslipToDatabase(
  userId: string,
  imageUrl: string,
  sportsbook: string,
  selections: (BetSelection & { currentOdds?: any })[],
  rawOcrText: string,
  llmResponse: any,
  scanConfidence: number,
  oddsWereFetched: boolean,
  hitRatesData?: Record<string, any>
) {
  const supabase = createClient()
  
  try {
    // Insert the main betslip record
    const { data: betslip, error: betslipError } = await supabase
      .from('scanned_betslips')
      .insert({
        user_id: userId,
        image_url: imageUrl,
        sportsbook: sportsbook,
        total_selections: selections.length,
        scan_confidence: scanConfidence,
        raw_ocr_text: rawOcrText,
        llm_response: llmResponse,
        status: 'active',
        last_odds_refresh: oddsWereFetched ? new Date().toISOString() : null, // Set if we fetched odds
        hit_rates_data: hitRatesData || {}
      })
      .select()
      .single()

    if (betslipError) {
      console.error('Error saving betslip:', betslipError)
      throw betslipError
    }

    console.log(`üíæ Saved betslip ${betslip.id} to database`)

    // Insert all selections
    const selectionsToInsert = selections.map(selection => ({
      scanned_betslip_id: betslip.id,
      sport: selection.sport,
      sport_api_key: selection.sportApiKey,
      event_id: selection.gameId,
      player_name: selection.player,
      market: selection.market,
      market_api_key: selection.marketApiKey,
      line: selection.line,
      bet_type: selection.betType,
      away_team: selection.metadata.awayTeam,
      home_team: selection.metadata.homeTeam,
      game_time: selection.metadata.gameTime,
      original_odds: selection.metadata.odds,
      current_odds: selection.currentOdds || {}, // Store the fetched odds
      confidence: selection.confidence,
      raw_text: selection.rawText
    }))

    const { error: selectionsError } = await supabase
      .from('scanned_betslip_selections')
      .insert(selectionsToInsert)

    if (selectionsError) {
      console.error('Error saving selections:', selectionsError)
      throw selectionsError
    }

    console.log(`‚úÖ Saved betslip ${betslip.id} with ${selections.length} selections (including odds) to database`)
    return betslip.id
    
  } catch (error) {
    console.error('Database save error:', error)
    throw error
  }
}

// Enhanced player name matching with fuzzy logic (copied from refresh endpoint)
function normalizePlayerName(name: string): string {
  return name
    .toLowerCase()
    .replace(/[.,\-]/g, '')
    .replace(/\s+/g, ' ')
    .trim()
}

function extractPlayerNameVariations(playerName: string): string[] {
  const normalized = normalizePlayerName(playerName)
  const variations = [normalized]
  
  // Split by spaces to handle "First Last" cases
  const parts = normalized.split(' ')
  
  if (parts.length >= 2) {
    // Add "Last, First" format
    variations.push(`${parts[parts.length - 1]} ${parts[0]}`)
    
    // Add "F. Last" format (first initial)
    variations.push(`${parts[0][0]} ${parts[parts.length - 1]}`)
    
    // Add "First L." format (last initial)
    variations.push(`${parts[0]} ${parts[parts.length - 1][0]}`)
    
    // NOTE: Removed individual first/last name matching as it's too permissive
    // This was causing "Kyle" to match both "Kyle Schwarber" and "Kyle Stowers"
  }
  
  return variations
}

function calculateNameSimilarity(target: string, candidate: string): number {
  const targetNorm = normalizePlayerName(target)
  const candidateNorm = normalizePlayerName(candidate)
  
  // Exact match gets highest score
  if (targetNorm === candidateNorm) {
    return 1.0
  }
  
  // Check if all words in target are in candidate (and vice versa)
  const targetWords = targetNorm.split(' ')
  const candidateWords = candidateNorm.split(' ')
  
  // For player names, we want both first and last name to match reasonably well
  if (targetWords.length >= 2 && candidateWords.length >= 2) {
    // Both names should have matching first and last names
    const firstNameMatch = targetWords[0] === candidateWords[0] || 
                          targetWords[0].startsWith(candidateWords[0][0]) ||
                          candidateWords[0].startsWith(targetWords[0][0])
    
    const lastNameMatch = targetWords[targetWords.length - 1] === candidateWords[candidateWords.length - 1]
    
    if (firstNameMatch && lastNameMatch) {
      return 0.9 // High confidence for first+last match
    }
    
    if (lastNameMatch && targetWords[0][0] === candidateWords[0][0]) {
      return 0.8 // Good confidence for last name + first initial
    }
  }
  
  // Check if one name contains the other (less preferred)
  if (targetNorm.includes(candidateNorm) || candidateNorm.includes(targetNorm)) {
    return 0.6 // Lower confidence for partial matches
  }
  
  return 0.0 // No match
}

function findPlayerInOutcomes(playerName: string, outcomes: Outcome[]): Outcome[] {
  const playerVariations = extractPlayerNameVariations(playerName)
  const candidateMatches: { outcome: Outcome; score: number }[] = []
  
  for (const outcome of outcomes) {
    if (!outcome.description) continue
    
    // Calculate similarity scores for all variations
    let bestScore = 0
    for (const variation of playerVariations) {
      const score = calculateNameSimilarity(variation, outcome.description)
      bestScore = Math.max(bestScore, score)
    }
    
    // Also try the original player name directly
    const directScore = calculateNameSimilarity(playerName, outcome.description)
    bestScore = Math.max(bestScore, directScore)
    
    // Only consider matches with a reasonable similarity score
    if (bestScore >= 0.7) { // Require at least 70% confidence
      candidateMatches.push({ outcome, score: bestScore })
    }
  }
  
  // Sort by confidence score (highest first) and return outcomes
  candidateMatches.sort((a, b) => b.score - a.score)
  
  // Log the matching process for debugging
  if (candidateMatches.length > 0) {
    console.log(`üéØ Player "${playerName}" matches:`)
    candidateMatches.forEach((match, i) => {
      console.log(`  ${i + 1}. "${match.outcome.description}" (confidence: ${(match.score * 100).toFixed(1)}%)`)
    })
    
    // Only return the best match(es) if they're significantly better than others
    const bestScore = candidateMatches[0].score
    const topMatches = candidateMatches.filter(m => m.score >= bestScore - 0.1) // Within 10% of best
    
    // If we have multiple perfect matches (like different lines for same player), return all of them
    if (bestScore >= 0.9 && topMatches.length > 1) {
      console.log(`‚úÖ Returning ${topMatches.length} high-confidence matches for line searching`)
      return topMatches.map(m => m.outcome)
    }
    // If we have one clear best match or ambiguous matches
    else if (topMatches.length === 1 || bestScore >= 0.9) {
      // Return only the best match if it's clearly the best or very confident
      return [candidateMatches[0].outcome]
    } else {
      // Return top matches if there's ambiguity
      return topMatches.map(m => m.outcome)
    }
  }
  
  console.log(`‚ùå No confident matches found for player "${playerName}"`)
  return []
}

function findMatchingOutcome(
  playerName: string, 
  line: number, 
  betType: string, 
  outcomes: Outcome[]
): Outcome | null {
  const playerOutcomes = findPlayerInOutcomes(playerName, outcomes)
  
  if (playerOutcomes.length === 0) {
    return null
  }
  
  console.log(`üîç Found ${playerOutcomes.length} player outcome(s) for "${playerName}"`)
  
  // Find outcome with matching line and bet type
  const targetName = betType.toLowerCase() === 'over' ? 'Over' : 'Under'
  
  // First try exact match
  for (const outcome of playerOutcomes) {
    if (outcome.name === targetName && outcome.point === line) {
      console.log(`‚úÖ Exact match: ${outcome.description} ${outcome.name} ${outcome.point} @ ${outcome.price}`)
      return outcome
    }
  }
  
  // Special handling for strikeouts: if we're looking for whole number (6), also try +0.5 (6.5)
  const isStrikeoutMarket = playerOutcomes.some(o => 
    o.description?.toLowerCase().includes('strikeout') || 
    o.description?.toLowerCase().includes('so') ||
    o.description?.toLowerCase().includes('k')
  )
  
  if (isStrikeoutMarket) {
    // If we have a whole number (6), try -0.5 (5.5) because "6+" means "Over 5.5"
    if (Number.isInteger(line)) {
      console.log(`üéØ Strikeout market detected - trying line conversion: ${line}+ -> Over ${line - 0.5}`)
      for (const outcome of playerOutcomes) {
        if (outcome.name === targetName && outcome.point === line - 0.5) {
          console.log(`‚úÖ Strikeout conversion match: ${outcome.description} ${outcome.name} ${outcome.point} @ ${outcome.price}`)
          return outcome
        }
      }
    }
    // If we have a half number (5.5), try +0.5 (6) because API "Over 5.5" = sportsbook "6+"
    else if (line % 1 === 0.5) {
      console.log(`üéØ Strikeout market detected - trying line conversion: Over ${line} -> ${line + 0.5}+`)
      for (const outcome of playerOutcomes) {
        if (outcome.name === targetName && outcome.point === line + 0.5) {
          console.log(`‚úÖ Strikeout reverse conversion match: ${outcome.description} ${outcome.name} ${outcome.point} @ ${outcome.price}`)
          return outcome
        }
      }
    }
  }
  
  // STRICT MATCHING: If exact line not found, do NOT use fuzzy matching
  // This prevents comparing different lines (e.g., 2+ vs 2.5+ vs 3+ total bases)
  console.log(`‚ùå No exact match found for "${playerName}" ${betType} ${line} - excluding this sportsbook from comparison`)
  console.log(`üìã Available lines for this player: ${playerOutcomes.map(o => `${o.name} ${o.point}`).join(', ')}`)
  return null
}

// Fetch odds for a specific selection
async function fetchOddsForSelection(
  selection: BetSelection,
  apiKey: string,
  activeSportsbooks: string[]
): Promise<any> {
  if (!selection.gameId) {
    return {
      error: 'No event ID available',
      metadata: {
        matches_found: 0,
        total_bookmakers: 0,
        best_odds: null,
        best_book: null,
        player_searched: selection.player || '',
        line_searched: selection.line || 0,
        bet_type_searched: selection.betType,
        market_searched: selection.marketApiKey,
        last_updated: new Date().toISOString(),
        error: 'No event ID available'
      }
    }
  }

  try {
    console.log(`üéØ Fetching odds for: ${selection.player} - ${selection.market} ${selection.betType} ${selection.line}`)
    
    // Determine which markets to fetch (standard + alternate if available)
    const marketsToFetch = [selection.marketApiKey]
    
    // Check if this market has alternates and add them
    const marketConfig: SportMarket | undefined = getMarketsForSport(selection.sportApiKey).find(m => m.value === selection.market)
    if (marketConfig?.hasAlternates && marketConfig.alternateKey) {
      marketsToFetch.push(marketConfig.alternateKey)
      console.log(`üìä Including alternate market: ${marketConfig.alternateKey}`)
    }
    
    // Build API URL with all active sportsbooks and markets
    const oddsUrl = `https://api.the-odds-api.com/v4/sports/${selection.sportApiKey}/events/${selection.gameId}/odds`
    const params = new URLSearchParams({
      apiKey,
      regions: 'us',
      markets: marketsToFetch.join(','), // Fetch both standard and alternate markets
      oddsFormat: 'american',
      bookmakers: activeSportsbooks.join(','),
      includeSids: 'true',
      includeLinks: 'true'
    })

    console.log(`üìû API Call: ${oddsUrl}?${params.toString()}`)
    console.log(`üìä Fetching markets: ${marketsToFetch.join(', ')}`)
    
    const oddsResponse = await fetch(`${oddsUrl}?${params.toString()}`)

    if (!oddsResponse.ok) {
      console.error(`‚ùå Failed to fetch odds for ${selection.gameId}: ${oddsResponse.status}`)
      return {
        error: `API error: ${oddsResponse.status}`,
        metadata: {
          matches_found: 0,
          total_bookmakers: 0,
          best_odds: null,
          best_book: null,
          player_searched: selection.player || '',
          line_searched: selection.line || 0,
          bet_type_searched: selection.betType,
          market_searched: selection.marketApiKey,
          last_updated: new Date().toISOString(),
          error: `API error: ${oddsResponse.status}`
        }
      }
    }

    const oddsData: OddsResponse = await oddsResponse.json()
    console.log(`‚úÖ Fetched odds data with ${oddsData.bookmakers?.length || 0} bookmakers`)

    if (!oddsData.bookmakers || oddsData.bookmakers.length === 0) {
      console.log(`‚ö†Ô∏è No bookmakers data for ${selection.player}`)
      return {
        error: 'No bookmakers available',
        metadata: {
          matches_found: 0,
          total_bookmakers: 0,
          best_odds: null,
          best_book: null,
          player_searched: selection.player || '',
          line_searched: selection.line || 0,
          bet_type_searched: selection.betType,
          market_searched: selection.marketApiKey,
          last_updated: new Date().toISOString(),
          error: 'No bookmakers available'
        }
      }
    }

    // Find odds across all sportsbooks and markets
    const allBookmakerOdds: Record<string, any> = {}
    let bestOdds: number | null = null
    let bestBook: string | null = null
    let foundMatches = 0

    for (const bookmaker of oddsData.bookmakers) {
      // Look for the player across ALL markets (standard + alternate)
      const allOutcomes: Outcome[] = []
      
      for (const marketKey of marketsToFetch) {
        const market = bookmaker.markets.find(m => m.key === marketKey)
        if (market) {
          console.log(`üìä Found market ${marketKey} for ${bookmaker.key} with ${market.outcomes?.length || 0} outcomes`)
          allOutcomes.push(...(market.outcomes || []))
        } else {
          console.log(`‚ö†Ô∏è Market ${marketKey} not found for ${bookmaker.key}`)
        }
      }

      if (allOutcomes.length === 0) {
        console.log(`‚ö†Ô∏è No markets found for ${bookmaker.key}`)
        continue
      }

      // Find the specific player + line + bet type across all outcomes
      const matchingOutcome = findMatchingOutcome(
        selection.player || '',
        selection.line || 0,
        selection.betType,
        allOutcomes
      )

      if (matchingOutcome) {
        foundMatches++
        console.log(`‚úÖ Found match for ${selection.player} at ${bookmaker.key}: ${matchingOutcome.name} ${matchingOutcome.point} @ ${matchingOutcome.price}`)
        
        allBookmakerOdds[bookmaker.key] = {
          price: matchingOutcome.price,
          point: matchingOutcome.point,
          link: matchingOutcome.link || null,
          sid: matchingOutcome.sid || null,
          last_update: bookmaker.last_update
        }

        // Track best odds (highest for positive, closest to 0 for negative)
        if (bestOdds === null || 
            (matchingOutcome.price > 0 && matchingOutcome.price > bestOdds) ||
            (matchingOutcome.price < 0 && bestOdds < 0 && matchingOutcome.price > bestOdds)) {
          bestOdds = matchingOutcome.price
          bestBook = bookmaker.key
        }
      } else {
        console.log(`‚ùå No match found for ${selection.player} ${selection.betType} ${selection.line} at ${bookmaker.key}`)
      }
    }

    // Create comprehensive odds object
    const currentOdds = {
      bookmakers: allBookmakerOdds,
      metadata: {
        matches_found: foundMatches,
        total_bookmakers: oddsData.bookmakers.length,
        best_odds: bestOdds,
        best_book: bestBook,
        player_searched: selection.player || '',
        line_searched: selection.line || 0,
        bet_type_searched: selection.betType,
        market_searched: marketsToFetch.join(','), // Include all markets searched
        last_updated: new Date().toISOString()
      } as OddsMetadata
    }

    if (foundMatches === 0) {
      console.log(`‚ö†Ô∏è No matches found for ${selection.player} across any sportsbooks`)
      currentOdds.metadata.error = 'Player/line combination not found in any sportsbook'
    } else {
      console.log(`‚úÖ Found ${foundMatches} matches for ${selection.player}`)
    }

    return currentOdds

  } catch (error) {
    console.error(`‚ùå Error fetching odds for selection:`, error)
    return {
      error: 'Error fetching odds',
      details: error instanceof Error ? error.message : 'Unknown error',
      metadata: {
        matches_found: 0,
        total_bookmakers: 0,
        best_odds: null,
        best_book: null,
        player_searched: selection.player || '',
        line_searched: selection.line || 0,
        bet_type_searched: selection.betType,
        market_searched: selection.marketApiKey,
        last_updated: new Date().toISOString(),
        error: 'Error fetching odds'
      }
    }
  }
}

// Helper function to fetch hit rates for all selections
async function fetchHitRatesForSelections(selections: BetSelection[]): Promise<Record<string, any>> {
  try {
    const hitRatesData: Record<string, any> = {}
    
    for (const selection of selections) {
      if (!selection.player) continue
      
      try {
        // Try multiple market name variations to handle mismatches between LLM parsing, database names, and our mapping
        const marketVariations = [
          selection.market, // Original parsed market (e.g., "Home_Runs")
          selection.market.replace(/_/g, ' '), // Replace underscores with spaces (e.g., "Home Runs")
          selection.market.replace(/\s+/g, '_'), // Replace spaces with underscores 
          selection.market.toLowerCase(), // lowercase version
          selection.market.toUpperCase(), // uppercase version
          
          // Specific database mappings we know exist
          selection.market.replace(/Home_Runs/i, 'Home Runs'),
          selection.market.replace(/Home Runs/i, 'Home_Runs'),
          selection.market.replace(/Total_Bases/i, 'Total Bases'),
          selection.market.replace(/Total Bases/i, 'Total_Bases'),
          
          // Common variations
          'Strikeouts', // Database format
          'Home Runs', // Database format  
          'Hits',
          'Total Bases',
          'RBIs'
        ]
        
        // Remove duplicates
        const uniqueMarkets = Array.from(new Set(marketVariations))
        
        let hitRateData = null
        
        // Try each market variation until we find a match
        for (const marketVariation of uniqueMarkets) {
          const response = await fetch(`${process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000'}/api/player-hit-rate?playerName=${encodeURIComponent(selection.player)}&market=${encodeURIComponent(marketVariation)}`)
          
          if (response.ok) {
            const responseData = await response.json()
            if (responseData.profile) {
              hitRateData = responseData.profile
              console.log(`‚úÖ Hit rate found for ${selection.player} with market "${marketVariation}"`)
              break
            }
          }
        }
        
        if (hitRateData) {
          hitRatesData[selection.player] = hitRateData
        } else {
          console.log(`‚ö†Ô∏è No hit rate data found for ${selection.player} with any market variation: ${uniqueMarkets.join(', ')}`)
        }
        
      } catch (error) {
        console.error(`‚ùå Error fetching hit rate for ${selection.player}:`, error)
        continue
      }
    }
    
    console.log(`üìä Hit rate data fetched for ${Object.keys(hitRatesData).length}/${selections.length} players`)
    return hitRatesData
  } catch (error) {
    console.error('‚ùå Error in fetchHitRatesForSelections:', error)
    return {}
  }
}

export async function POST(request: NextRequest) {
  try {
    // ‚ö†Ô∏è AUTHENTICATION CHECK - Must be first
    const supabase = createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()
    
    if (authError || !user) {
      console.log('‚ùå Authentication failed - redirecting to sign-in')
      return NextResponse.json(
        { 
          error: 'Authentication required',
          redirectTo: '/sign-in',
          message: 'You must be signed in to use the betslip scanner'
        },
        { status: 401 }
      )
    }

    console.log(`‚úÖ User authenticated: ${user.id}`)

    // Parse form data
    const formData = await request.formData()
    const imageFile = formData.get('image') as File
    
    if (!imageFile) {
      return NextResponse.json(
        { error: 'No image file provided' },
        { status: 400 }
      )
    }

    console.log(`üì∑ Processing image: ${imageFile.name} (${imageFile.size} bytes)`)

    // Convert file to buffer for Vision API
    const imageBuffer = Buffer.from(await imageFile.arrayBuffer())

    // Extract text using existing OCR function
    console.log('üîç Running OCR extraction...')
    const extractedText = await extractTextFromImage(imageBuffer)
    
    if (!extractedText.trim()) {
      return NextResponse.json(
        { error: 'No text found in image' },
        { status: 400 }
      )
    }

    console.log('üìù OCR Text extracted:', extractedText.substring(0, 200) + '...')

    // Parse with enhanced LLM function
    console.log('ü§ñ Parsing with LLM...')
    const llmResult = await parseWithLLMEnhanced(extractedText)
    
    if (!llmResult.success || !llmResult.data) {
      return NextResponse.json(
        { 
          error: 'Failed to parse betslip', 
          details: llmResult.error,
          rawText: extractedText 
        },
        { status: 400 }
      )
    }

    const { sportsbook, selections: parsedSelections, confidence } = llmResult.data

    console.log(`üéØ Parsed ${parsedSelections.length} selections from ${sportsbook}`)

    // Process each selection with event matching
    const processedSelections: BetSelection[] = []
    const today = new Date().toISOString().split('T')[0]

    for (const selection of parsedSelections) {
      try {
        console.log(`üîÑ Processing: ${selection.player} - ${selection.market}`)
        
        // Get sport API key
        const sportApiKey = getSportApiKey(selection.sport)
        if (!sportApiKey) {
          console.log(`‚ö†Ô∏è Unsupported sport: ${selection.sport}`)
          continue
        }

        // Get market API key
        const marketApiKey = getMarketApiKey(selection.sportApiKey, selection.market)
        if (!marketApiKey) {
          console.log(`‚ö†Ô∏è Unsupported market: ${selection.market}`)
          continue
        }

        // Fetch today's games for event matching
        const games = await fetchTodaysGames(sportApiKey, today)
        console.log(`üéÆ Found ${Object.keys(games).length} games for ${sportApiKey} on ${today}`)
        
        const matchedGame = findMatchingGame(games, selection.metadata.awayTeam, selection.metadata.homeTeam)

        const processedSelection: BetSelection = {
          id: selection.id,
          player: selection.player,
          market: selection.market,
          line: selection.line,
          betType: selection.betType,
          sport: selection.sport,
          sportApiKey,
          marketApiKey,
          gameId: matchedGame?.event_id,
          confidence: selection.confidence,
          rawText: selection.rawText,
          metadata: selection.metadata
        }

        processedSelections.push(processedSelection)

        if (matchedGame) {
          console.log(`‚úÖ Matched: ${selection.player} -> ${matchedGame.event_id}`)
        } else {
          console.log(`‚ö†Ô∏è No match: ${selection.player} (${selection.metadata.awayTeam} vs ${selection.metadata.homeTeam})`)
        }
        
      } catch (error) {
        console.error(`‚ùå Error processing selection:`, error)
        // Continue processing other selections
      }
    }

    console.log(`\nüí∞ Fetching current odds for ${processedSelections.length} selections...`)

    // Get API key for odds fetching
    const apiKey = process.env.ODDS_API_KEY
    if (!apiKey) {
      console.warn('ODDS_API_KEY not configured, skipping odds fetch')
    }

    // Get active sportsbooks
    const activeSportsbooks = sportsbooks
      .filter(book => book.isActive)
      .map(book => book.id)
    
    console.log(`üìö Using ${activeSportsbooks.length} active sportsbooks: ${activeSportsbooks.join(', ')}`)

    // Fetch odds for each selection (if API key is available)
    const selectionsWithOdds: (BetSelection & { currentOdds?: any })[] = []
    
    if (apiKey && activeSportsbooks.length > 0) {
      for (const selection of processedSelections) {
        try {
          // Skip odds fetching if no event ID (game not matched)
          if (!selection.gameId) {
            console.log(`‚ö†Ô∏è Skipping odds fetch for ${selection.player} - no event ID`)
            selectionsWithOdds.push({
              ...selection,
              currentOdds: {
                error: 'No event ID available',
                metadata: {
                  matches_found: 0,
                  total_bookmakers: 0,
                  best_odds: null,
                  best_book: null,
                  player_searched: selection.player || '',
                  line_searched: selection.line || 0,
                  bet_type_searched: selection.betType,
                  market_searched: selection.marketApiKey,
                  last_updated: new Date().toISOString(),
                  error: 'No event ID available - game not matched'
                }
              }
            })
            continue
          }

          const oddsData = await fetchOddsForSelection(selection, apiKey, activeSportsbooks)
          selectionsWithOdds.push({
            ...selection,
            currentOdds: oddsData
          })
        } catch (error) {
          console.error(`‚ùå Error fetching odds for ${selection.player}:`, error)
          // Add selection without odds if fetching fails
          selectionsWithOdds.push({
            ...selection,
            currentOdds: {
              error: 'Failed to fetch odds',
              metadata: {
                matches_found: 0,
                total_bookmakers: 0,
                best_odds: null,
                best_book: null,
                player_searched: selection.player || '',
                line_searched: selection.line || 0,
                bet_type_searched: selection.betType,
                market_searched: selection.marketApiKey,
                last_updated: new Date().toISOString(),
                error: 'Failed to fetch odds'
              }
            }
          })
        }
      }
    } else {
      // If no API key, just add selections without odds
      selectionsWithOdds.push(...processedSelections.map(sel => ({ ...sel, currentOdds: {} })))
    }

    console.log(`‚úÖ Completed odds fetching for ${selectionsWithOdds.length} selections`)

    // Fetch hit rate data for all selections
    console.log(`üìä Fetching hit rate data for ${selectionsWithOdds.length} selections...`)
    const hitRatesData = await fetchHitRatesForSelections(selectionsWithOdds)
    console.log(`‚úÖ Hit rate data fetched for ${Object.keys(hitRatesData).length} players`)

    // Save to database
    let savedBetslipId = null
    try {
      savedBetslipId = await saveBetslipToDatabase(
        user.id,
        `/uploads/betslips/${imageFile.name}`, // You'll need to implement file upload
        sportsbook,
        selectionsWithOdds,
        extractedText,
        llmResult.data,
        confidence,
        apiKey !== undefined && apiKey !== null,
        hitRatesData
      )

      console.log(`üíæ Betslip saved successfully: ${savedBetslipId}`)
      
    } catch (dbError) {
      console.error('Database save failed:', dbError)
      // Don't fail the request, just log the error
    }

    // Return successful response
    return NextResponse.json({
      success: true,
      data: {
        sportsbook,
        totalSelections: selectionsWithOdds.length,
        confidence,
        selections: selectionsWithOdds,
        userId: user.id,
        savedAt: new Date().toISOString(),
        savedBetslipId: savedBetslipId, // Include the betslip ID for redirect
        oddsData: {
          successfulOddsFetches: selectionsWithOdds.filter(s => 
            s.currentOdds?.metadata?.matches_found > 0
          ).length,
          failedOddsFetches: selectionsWithOdds.filter(s => 
            s.currentOdds?.error || s.currentOdds?.metadata?.matches_found === 0
          ).length,
          totalBookmakers: activeSportsbooks.length
        }
      }
    })

  } catch (error) {
    console.error('‚ùå Betslip extraction failed:', error)
    return NextResponse.json(
      { 
        error: 'Failed to process betslip',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    )
  }
} 